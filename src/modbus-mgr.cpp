//////////////////////////////////////////////////////////////////////////////
// Model: rtu.qm
// File:  ./modbus-mgr.cpp
//
// This code has been generated by QM tool (see state-machine.com/qm).
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This program is open source software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
// for more details.
//////////////////////////////////////////////////////////////////////////////
// @(/2/1) ...................................................................
#include <iostream>

#include "modbus.h"
#include "modbus-mgr.h"

using namespace std;

namespace Zebra {


static ModbusMgr modbusMgr("/dev/ttyS1", 115200, 'N', 8, 1);
QP::QActive * const AO_Modbus = &modbusMgr;

#ifdef     Q_SPY
enum ModbusRecords {
    MODBUS_INIT_CODE = QP::QS_USER,
    MODBUS_ENABLE_CODE
};
#endif

// @(/1/0) ...................................................................
// @(/1/0/4) .................................................................
ModbusMgr::ModbusMgr(
    const char* port,
    int32_t baud,
    char parity,
    int32_t data_bit,
    int32_t stop_bit)

  : QActive(Q_STATE_CAST(&ModbusMgr::initial)),
    _timeEvt(TIME_OUT_SIG)
{
    for (int i = 0; i < 8; ++i) {
        _tab_bits[i] = 0;
    }

    for (int i = 0; i < 8; ++i) {
        _table_registers[i] = 0;
    }

    ctx = modbus_new_rtu(port, baud, parity, data_bit, stop_bit);

}

// @(/1/0/5) .................................................................
// @(/1/0/5/0)
QP::QState ModbusMgr::initial(ModbusMgr * const me, QP::QEvt const * const e) {
    QS_OBJ_DICTIONARY(&modbusMgr);
    QS_OBJ_DICTIONARY(&modbusMgr._timeEvt);
    QS_FUN_DICTIONARY(&ModbusMgr::initial);
    QS_FUN_DICTIONARY(&ModbusMgr::running);
    QS_SIG_DICTIONARY(TIME_OUT_SIG, me);

    modbus_rtu_set_serial_mode(me->ctx, MODBUS_RTU_RS485);
    modbus_rtu_set_rts(me->ctx, MODBUS_RTU_RTS_DOWN);

    //modbus_set_debug(me->ctx, TRUE);

    if (modbus_connect(me->ctx) == -1) {
    //TODO
    }

    modbus_set_slave(me->ctx, 0x02);


    me->subscribe(TIME_OUT_SIG);
    return Q_TRAN(&ModbusMgr::running);
}
// @(/1/0/5/1) ...............................................................
QP::QState ModbusMgr::running(ModbusMgr * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // @(/1/0/5/1)
        case Q_ENTRY_SIG: {
            me->_timeEvt.postEvery(me, Zebra::BSP_TICKS_PER_SEC * 100);
            status_ = Q_HANDLED();
            break;
        }
        // @(/1/0/5/1)
        case Q_EXIT_SIG: {
            me->_timeEvt.disarm();
            status_ = Q_HANDLED();
            break;
        }
        // @(/1/0/5/1/0)
        case TIME_OUT_SIG: {
            int rc = modbus_read_input_bits(me->ctx, 0, 8, me->_tab_bits);
            if (rc != 8) {
                std::cout << "FAILED, number of points = " << rc << std::endl;
            }

            /*
            uint8_t tab_value[8] = {1, 0, 1, 0, 1, 0, 1, 0};
            rc = modbus_write_bits(me->ctx, 0, 8, tab_value);
            if (rc != 8) {
                std::cout << "FAILED, number of bits = " << rc << std::endl;
            }

            rc = modbus_read_input_registers(me->ctx, 0, 8, me->_table_registers);
            if (rc != 8) {
                std::cout << "FAILED, number of registers = " << rc << std::endl;
            }

            */
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm::top);
            break;
        }
    }
    return status_;
}



}  // namespace Zebra
